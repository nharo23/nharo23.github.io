{"meta":{"title":"잡동사니 모음","subtitle":"잊어버리기 쉬운 1원짜리 팁들의 모음","description":null,"author":"Kangjin Cho","url":"http://nharo23.github.io"},"pages":[],"posts":[{"title":"[AWS] ElasticSearch Service 수동 스냅샷 및 복원","slug":"AWS-ElasticSearch-Service-수동-스냅샷-및-복원","date":"2018-08-18T02:03:57.000Z","updated":"2018-08-18T02:07:41.000Z","comments":true,"path":"2018/08/18/AWS-ElasticSearch-Service-수동-스냅샷-및-복원/index.html","link":"","permalink":"http://nharo23.github.io/2018/08/18/AWS-ElasticSearch-Service-수동-스냅샷-및-복원/index.html","excerpt":"","text":"IAM Role, Policy 설정하는 법은 AWS 문서를 참고. 해당 Policy 로 인스턴스를 생성한 이후에 작업하는 것을 기록. [https://docs.aws.amazon.com/ko_kr/elasticsearch-service/latest/developerguide/es-managedomains-snapshots.html#es-managedomains-snapshot-create] A 에서 B로 옮기는 경우 A에서 스냅샷을 생성 한다음. B에서 repo를 A의 것으로 등록한다음 A에서 스냅샷 한것을 이용하여서 리스토어를 한다.","categories":[],"tags":[{"name":"aws, es","slug":"aws-es","permalink":"http://nharo23.github.io/tags/aws-es/"}]},{"title":"[JAVA] Hibernate Second Level Cache","slug":"JAVA-Hibernate-Second-Level-Cache","date":"2018-08-18T02:01:46.000Z","updated":"2018-08-18T02:02:25.000Z","comments":true,"path":"2018/08/18/JAVA-Hibernate-Second-Level-Cache/index.html","link":"","permalink":"http://nharo23.github.io/2018/08/18/JAVA-Hibernate-Second-Level-Cache/index.html","excerpt":"","text":"http://www.baeldung.com/hibernate-second-level-cache second-level cache is SessionFactory-scoped, meaning it is shared by all sessions created with the same session factory Also, the loaded instance state is stored in L2 cache if it was not there already. Enabling Second-level Cachinghibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory Making an Entity Cachable @Entity @Cacheable @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) public class Foo { @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = &quot;ID&quot;) private long id; @Column(name = &quot;NAME&quot;) private String name; // getters and setters } Cache Concurrency Strategy Based on use cases, we are free to pick one of the following cache concurrency strategies: READ_ONLY: Used only for entities that never change (exception is thrown if an attempt to update such an entity is made). It is very simple and performant. Very suitable for some static reference data that don’t change NONSTRICT_READ_WRITE: Cache is updated after a transaction that changed the affected data has been committed. Thus, strong consistency is not guaranteed and there is a small time window in which stale data may be obtained from cache. This kind of strategy is suitable for use cases that can tolerate eventual consistency READ_WRITE: This strategy guarantees strong consistency which it achieves by using ‘soft’ locks: When a cached entity is updated, a soft lock is stored in the cache for that entity as well, which is released after the transaction is committed. All concurrent transactions that access soft-locked entries will fetch the corresponding data directly from database TRANSACTIONAL: Cache changes are done in distributed XA transactions. A change in a cached entity is either committed or rolled back in both database and cache in the same XA transaction XA Transaction https://docs.microsoft.com/ko-kr/sql/connect/jdbc/understanding-xa-transactionsXA transactions are designed to allow distributed transactions, where a transaction manager (the application) controls a transaction which involves multiple resources. Such resources are usually DBMSs, but could be resources of any type. The whole set of required transactional operations is called a global transaction. Each subset of operations which involve a single resource is called a local transaction. XA used a 2-phases commit (2PC). With the first commit, the transaction manager tells each resource to prepare an effective commit, and waits for a confirm message. The changes are not still made effective at this point. If any of the resources encountered an error, the transaction manager will rollback the global transaction. If all resources communicate that the first commit is successful, the transaction manager can require a second commit, which makes the changes effective. Tutorial https://github.com/eugenp/tutorials/tree/master/persistence-modules/spring-jpa","categories":[],"tags":[{"name":"java, development","slug":"java-development","permalink":"http://nharo23.github.io/tags/java-development/"}]},{"title":"[Github] 하나의 컴퓨터에서 복수 계정에 대한 RSA 만들기","slug":"Github-하나의-컴퓨터에서-복수-계정에-대한-RSA-만들기","date":"2018-08-18T01:54:48.000Z","updated":"2018-08-18T02:02:32.000Z","comments":true,"path":"2018/08/18/Github-하나의-컴퓨터에서-복수-계정에-대한-RSA-만들기/index.html","link":"","permalink":"http://nharo23.github.io/2018/08/18/Github-하나의-컴퓨터에서-복수-계정에-대한-RSA-만들기/index.html","excerpt":"","text":"나의 경우 회사 계정, 개인 계정이 따로 있고 ssh key를 회사용으로 등록해놓았다. 개인 계정의 git에 push를 하려니 fatal: Could not read from remote repository 오류 메세지만 나왔다. 관련해서 구글링 하다보니 아래 해법을 발견. [https://medium.freecodecamp.org/manage-multiple-github-accounts-the-ssh-way-2dadc30ccaca]","categories":[],"tags":[{"name":"git, github","slug":"git-github","permalink":"http://nharo23.github.io/tags/git-github/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-18T01:33:33.000Z","updated":"2018-08-18T01:33:33.000Z","comments":true,"path":"2018/08/18/hello-world/index.html","link":"","permalink":"http://nharo23.github.io/2018/08/18/hello-world/index.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}